#!/usr/bin/env python3

"""Tool to classify and sort downloaded bills.
"""


import calendar
import datetime
import json
import re
import os
import os.path
import logging
import shutil
import subprocess
import sys
import time
from optparse import OptionParser

try:                            # nice-to-have but not critical
    import colorlogger
except:
    pass

usage_string = """Usage:  %prog [options]
        %prog [options] <file(s)>

%prog processes all PDF documents in a specified directory and attempts
to identify bills and sort them out in to the destination directory using uniform
naming. The rules by which bills are identified and named are specified in the
configuration file.

"""

CONFIG_FILES = [ ".classify_bills.conf",
                 "classify_bills.conf",
                 "~/.classify_bills.conf",
                 "/etc/classify_bills.conf" ]

prog = os.path.basename(sys.argv[0])
program_version = 1.0
version_string = "%%prog  %s" % program_version


# parse command-line options

parser = OptionParser(usage = usage_string,
                      version = version_string)
parser.add_option("-O", "--output-dir", help="Output directory to use",
                  dest="output_dir", metavar="DIR")
parser.add_option("-f", "--force", help="perform actions (as opposed to dry run)",
                  action="store_true", dest="do_things")
parser.add_option("-w", "--overwrite", help="overwrite if destination file exists",
                  action="store_true", dest="overwrite")
parser.add_option("-i", "--ignore-errors", help="ignore errors",
                  action="store_true", dest="ignore_errors")
parser.add_option("-e", "--only-errors", help="only show errors",
                  action="store_true", dest="only_errors")
parser.add_option("-v", "--verbose", help="verbose operation",
                  action="store_true", dest="verbose_mode")

(options, args) = parser.parse_args()
logging.basicConfig(format="%(levelname)s: %(message)s")

if options.verbose_mode:
    logging.getLogger().setLevel(logging.DEBUG)
else:
    logging.getLogger().setLevel(logging.INFO)


# basic checks

if options.only_errors and (options.do_things or options.ignore_errors):
    logging.fatal("Conflicting options passed")
    sys.exit(1)

# read configuration

config = None
config_file = None

for f in CONFIG_FILES:
    if os.path.exists(f):
        config_file = f
        break

if not config_file:
    logging.fatal("No configuration file found")
    sys.exit(1)

with open(config_file) as f:
    try:
        config = json.load(f)
    except ValueError:
        logging.fatal("Parse error for config file '%s'", config_file)
        logging.fatal("(%s)", str(sys.exc_info()[1]))
        sys.exit(1)

if len(args) > 0:
    file_list = args
else:
    try:
        src_dir = os.path.expanduser(config['paths']['source-directory'])
    except:
        logging.error("Source directory not specified.")
        sys.exit(1)

    if not os.path.isdir(src_dir):
        logging.error("Source directory '%s' does not exist." % src_dir)
        sys.exit(1)

    file_list = [ os.path.join(src_dir, x) for x in os.listdir(src_dir) ]

if options.output_dir:
    dst_dir = options.output_dir
else:
    try:
        dst_dir = os.path.expanduser(config['paths']['destination-directory'])
    except:
        logging.error("Destination directory not specified.")
        sys.exit(1)

if not os.path.isdir(dst_dir):
    logging.error("Destination directory '%s' does not exist." % dst_dir)
    sys.exit(1)


# process each bill

dirs_created = {}
now = datetime.datetime.now()

devnull = open(os.devnull, 'wb')

for fname in file_list:
    short_fname = os.path.basename(fname)

    if not (fname.endswith('.pdf') or fname.endswith('.PDF')):
        logging.debug("Ignoring file '%s'", short_fname)
        continue

    processed = False

    try:
        process = subprocess.Popen(['pdftotext', fname, '-'],
                                   stdout=subprocess.PIPE,
                                   stderr=devnull)
        (text, stderr) = process.communicate()
        text = text.decode('utf-8')
        rc = process.returncode
    except OSError:
        logging.fatal("Error running pdftotext (not installed?)")
        sys.exit(1)

    if process.returncode != 0:
        if not options.ignore_errors:
            logging.error("Failed to extract text from file '%s'" %
                          short_fname)
        continue

    for acct in config['accounts']:
        account_name = acct['name']
        matches = True

        # match account

        for rx in acct['matches-all']:
            if not re.search(rx, text):
                matches = False
                break

        if not matches:
            continue

        logging.debug("%s: match successful for account '%s'",
                      short_fname, account_name)


        # extract date

        m = re.search(acct['date-extractor']['regexp'], text,
                      re.IGNORECASE | re.DOTALL)

        if m:
            datestr = m.group(1)
            logging.debug("%s: date matched for account '%s': '%s'",
                          short_fname, account_name, datestr)
            try:
                t = list(time.strptime(datestr,
                                       acct['date-extractor']['format']))
            except:
                logging.error("%s: failed to parse date string '%s' using format '%s'",
                              short_fname, datestr,
                              acct['date-extractor']['format'])
                break


            # There are 3 cases for the year
            # 1. Dates are listed without year (mm/dd). If we can extract year
            #    separately, we do it, otherwise we default to current year.
            # 2. Dates have short year (mm/dd/yy).
            # 3. Dates have full year.

            if t[0] < 100:
                t[0] += 2000

            elif t[0] == 1900:
                if 'year-extractor-regexp' in acct['date-extractor']:
                    m = re.search(acct['date-extractor']['year-extractor-regexp'], text)

                    if m:
                        t[0] = int(m.group(1))

                        if t[0] < 100:
                            t[0] += 2000

                        logging.debug("%s: year matched: '%d'", short_fname, t[0])
                else:
                    t[0] = now.year
                    logging.debug("%s: year implied: '%d'", short_fname, t[0])

            dt = datetime.datetime.fromtimestamp(time.mktime(tuple(t)))

            # adjust bill date 1 month back (if requested)

            if "adjust-month-back" in acct['date-extractor']:
                month = dt.month - 2
                year = dt.year + month // 12
                month = month % 12 + 1
                day = min(dt.day,calendar.monthrange(year,month)[1])
                dt = datetime.datetime(year,month,day)

            logging.debug("%s: bill date: %s", short_fname, str(dt.date()))
            out_dir = os.path.join(dst_dir, str(dt.year))

            if 'directory' in acct:
                out_dir = os.path.join(out_dir, acct['directory'])
            else:
                out_dir = os.path.join(out_dir, acct['name'])

            if os.path.exists(out_dir):
                if not os.path.isdir(out_dir):
                    logging.error("Destination %s is not a directory")
                    continue

            else:
                if options.do_things:
                    os.makedirs(out_dir)
                elif out_dir not in dirs_created:
                    logging.info("WILL MKDIR '%s'" % out_dir)
                    dirs_created[dst_dir] = True

            if 'name-template' in acct:
                tmpl = acct['name-template']
            else:
                tmpl = acct['name'] + " %Y-%m.pdf"

            quarter = ((dt.month - 1) / 3) + 1
            tmpl = tmpl.replace('%Q', "Q%d" % quarter, 1)
            out_fname = os.path.join(out_dir, dt.strftime(tmpl))
            logging.debug("%s: will be moved to %s", short_fname, out_fname)

            if options.do_things:
                if os.path.isfile(out_fname) and not options.overwrite:
                    logging.warn("not moving %s -> %s (destination file exists)" % (fname, out_fname))
                else:
                    logging.info("moving '%s'  ->  '%s'" % (fname, out_fname))
                    shutil.move(fname, out_fname)
            else:
                logging.info("WILL MOVE '%s'  ->  '%s'" % (fname, out_fname))

            processed = True
            break

    if not processed and not options.ignore_errors:
        logging.error("Failed to categorize %s" % short_fname)


sys.exit()


# Local Variables:
# compile-command: "pylint -r n testproc"
# end:
